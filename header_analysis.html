<script type="text/javascript">
    var gk_fileData = {};
    function loadFileData(filename) {
      return gk_fileData[filename] || "";
    }
    </script><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Email Analyser</title>
    <style>
        * * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

body {
    font-size: 12px;
    display: flex;
    min-height: 100vh;
    background-color: #f0f2f5;
}

.sidebar-container {
    display: flex;
    position: relative;
}

.sidebar {
    width: 300px;
    background-color: #ffffff;
    padding: 20px;
    box-shadow: 2px 0 5px rgba(0, 0, 0, 0.1);
    display: flex;
    flex-direction: column;
    gap: 15px;
    min-width: 200px;
    max-width: 500px;
}

.sidebar h2 {
    color: #333;
    font-size: 1.3em;
    margin-bottom: 10px;
}

.sidebar textarea {
    width: 100%;
    height: 200px;
    padding: 10px;
    border: 1px solid #ddd;
    border-radius: 5px;
    resize: none;
    font-size: 14px;
    background-color: #fafafa;
}

.sidebar textarea:focus {
    outline: none;
    border-color: #007bff;
    box-shadow: 0 0 5px rgba(0, 123, 255, 0.3);
}

.sidebar button {
    padding: 10px;
    border: none;
    border-radius: 5px;
    font-size: 14px;
    cursor: pointer;
    transition: background-color 0.3s;
}

.sidebar button#analyseBtn {
    background-color: #007bff;
    color: white;
}

.sidebar button#analyseBtn:hover {
    background-color: #0056b3;
}

.sidebar button#clearBtn {
    background-color: #dc3545;
    color: white;
}

.sidebar button#clearBtn:hover {
    background-color: #b02a37;
}

.resize-handle {
    width: 5px;
    background-color: #ddd;
    cursor: col-resize;
    transition: background-color 0.2s;
}

.resize-handle:hover {
    background-color: #bbb;
}

.main {
    flex: 1;
    padding: 20px;
    overflow-y: auto;
}

.main h2, .main h3 {
    color: #333;
    margin-bottom: 20px;
}

table {
    width: 100%;
    border-collapse: collapse;
    background-color: #ffffff;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    margin-bottom: 30px;
}

th, td {
    padding: 12px;
    font-size: 13px;
    text-align: left;
    border-bottom: 1px solid #ddd;
}

th {
    background-color: #007bff;
    color: white;
    cursor: pointer;
    position: relative;
    user-select: none;
}

th:hover {
    background-color: #0056b3;
}

th.sort-asc::after {
    content: '↑';
    position: absolute;
    right: 8px;
}

th.sort-desc::after {
    content: '↓';
    position: absolute;
    right: 8px;
}

tr:hover {
    background-color: #f8f9fa;
}

.body-section {
    background-color: #ffffff;
    padding: 20px;
    border-radius: 5px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    margin-bottom: 30px;
}

.body-section pre {
    white-space: pre-wrap;
    word-wrap: break-word;
    margin: 0;
    font-size: 14px;
}

.body-section .html-content {
    border: 1px solid #ddd;
    padding: 10px;
    border-radius: 5px;
}

.body-content-container {
    display: none;
    margin-top: 10px;
}

.body-content-container.expanded {
    display: block;
}

.attachments-section {
    background-color: #ffffff;
    padding: 20px;
    border-radius: 5px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    margin-bottom: 30px;
}

.attachments-section h3 {
    color: #333;
    margin-bottom: 15px;
}

.attachments-section table {
    margin-bottom: 0;
}

.attachments-section .download-btn {
    display: inline-block;
    padding: 8px 12px;
    background-color: #007bff;
    color: white;
    text-decoration: none;
    border-radius: 5px;
    font-size: 13px;
    transition: background-color 0.3s;
}

.attachments-section .download-btn:hover {
    background-color: #0056b3;
}

.ioc-section {
    background-color: #ffffff;
    padding: 20px;
    border-radius: 5px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
}

.ioc-section table {
    margin-bottom: 0;
}

.spf-section, .dkim-section, .dmarc-section {
    background-color: #ffffff;
    padding: 20px;
    border-radius: 5px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    margin-bottom: 20px;
}

.spf-section h3, .dkim-section h3, .dmarc-section h3 {
    color: #333;
    margin-bottom: 15px;
}

.spf-section table, .dkim-section table, .dmarc-section table {
    margin-bottom: 0;
}

.spf-status, .dkim-status, .dmarc-status {
    padding: 10px;
    margin-bottom: 10px;
    border-radius: 5px;
    color: white;
    font-weight: bold;
    text-align: center;
    display: inline-block;
    width: calc(100% - 30px);
}

.spf-pass, .dkim-pass, .dmarc-pass {
    background-color: #28a745;
}

.spf-fail, .dkim-fail, .dmarc-fail {
    background-color: #dc3545;
}

.bcl-section {
    background-color: #ffffff;
    padding: 20px;
    border-radius: 5px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    margin-bottom: 20px;
}

.bcl-section h3 {
    color: #333;
    margin-bottom: 15px;
}

.bcl-status {
    padding: 10px;
    margin-bottom: 10px;
    border-radius: 5px;
    color: white;
    font-weight: bold;
    text-align: center;
    display: inline-block;
    width: calc(100% - 30px);
}

.bcl-low {
    background-color: #28a745;
}

.bcl-medium {
    background-color: #ffc107;
}

.bcl-high, .bcl-na {
    background-color: #dc3545;
}

.bcl-details-container {
    display: none;
    margin-top: 10px;
}

.bcl-details-container.expanded {
    display: block;
}

.forefront-section {
    background-color: #ffffff;
    padding: 20px;
    border-radius: 5px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    margin-bottom: 20px;
}

.forefront-section h3 {
    color: #333;
    margin-bottom: 15px;
}

.forefront-section table {
    margin-bottom: 0;
}

.forefront-status {
    padding: 10px;
    margin-bottom: 10px;
    border-radius: 5px;
    color: white;
    font-weight: bold;
    text-align: center;
    display: inline-block;
    width: calc(100% - 30px);
    background-color: #17a2b8;
}

.forefront-status.na {
    background-color: #dc3545;
}

.header-section {
    overflow-x: auto;
    background-color: #ffffff;
    padding: 20px;
    border-radius: 5px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    margin-bottom: 20px;
}

.header-section table {
    width: 100%;
    max-width: 100%;
    table-layout: auto;
    margin-bottom: 0;
}

.spf-details, .dkim-details, .dmarc-details, .forefront-details, .bcl-details {
    white-space: pre-wrap;
    word-wrap: break-word;
}

.spf-details-container, .dkim-details-container, .dmarc-details-container, .forefront-details-container {
    display: none;
    margin-top: 10px;
}

.spf-details-container.expanded, .dkim-details-container.expanded, .dmarc-details-container.expanded, .forefront-details-container.expanded {
    display: block;
}

.toggle-spf-arrow, .toggle-dkim-arrow, .toggle-dmarc-arrow, .toggle-forefront-arrow, .toggle-header-arrow, .toggle-body-arrow, .toggle-bcl-arrow {
    cursor: pointer;
    font-size: 14px;
    margin-left: 10px;
    vertical-align: middle;
    color: #333;
    transition: color 0.3s;
}

.toggle-spf-arrow:hover, .toggle-dkim-arrow:hover, .toggle-dmarc-arrow:hover, .toggle-forefront-arrow:hover, .toggle-header-arrow:hover, .toggle-body-arrow:hover, .toggle-bcl-arrow:hover {
    color: #007bff;
}

.spf-status-container, .dkim-status-container, .dmarc-status-container, .forefront-status-container, .header-table-container, .body-content-toggle, .bcl-status-container {
    display: flex;
    align-items: center;
    margin-bottom: 10px;
}

.header-table-toggle {
    text-align: center;
    margin-bottom: 10px;
}

/* Adjust column widths for header table */
.header-section th:nth-child(1), .header-section td:nth-child(1) { /* Order */
    width: 10%;
    min-width: 50px;
}
.header-section th:nth-child(2), .header-section td:nth-child(2) { /* Action */
    width: 12%;
    min-width: 80px;
    word-wrap: break-word;
}
.header-section th:nth-child(3), .header-section td:nth-child(3) { /* Timestamp */
    width: 16%;
    min-width: 120px;
    word-wrap: break-word;
}
.header-section th:nth-child(4), .header-section td:nth-child(4) { /* From Server */
    width: 15%;
    min-width: 100px;
    word-wrap: break-word;
}
.header-section th:nth-child(5), .header-section td:nth-child(5) { /* By Server */
    width: 15%;
    min-width: 100px;
    word-wrap: break-word;
}
.header-section th:nth-child(6), .header-section td:nth-child(6) { /* IP */
    width: 12%;
    min-width: 80px;
    word-wrap: break-word;
}
.header-section th:nth-child(7), .header-section td:nth-child(7) { /* Email/Domain */
    width: 15%;
    min-width: 100px;
    word-wrap: break-word;
}
.header-section th:nth-child(8), .header-section td:nth-child(8) { /* Details */
    width: 15%;
    min-width: 100px;
    word-wrap: break-word;
}

/* Improve text wrapping in header table cells */
.header-section td, .header-section th {
    word-break: break-word;
    overflow-wrap: break-word;
    padding: 8px;
}

/* Adjust column widths for IOC, SPF, DKIM, DMARC, Forefront, and Attachments tables */
.ioc-section th:nth-child(1), .ioc-section td:nth-child(1),
.spf-section th:nth-child(1), .spf-section td:nth-child(1),
.dkim-section th:nth-child(1), .dkim-section td:nth-child(1),
.dmarc-section th:nth-child(1), .dmarc-section td:nth-child(1),
.forefront-section th:nth-child(1), .forefront-section td:nth-child(1),
.attachments-section th:nth-child(1), .attachments-section td:nth-child(1) { /* Type/Field/Name */
    width: 40%;
}
.ioc-section th:nth-child(2), .ioc-section td:nth-child(2),
.spf-section th:nth-child(2), .spf-section td:nth-child(2),
.dkim-section th:nth-child(2), .dkim-section td:nth-child(2),
.dmarc-section th:nth-child(2), .dmarc-section td:nth-child(2),
.forefront-section th:nth-child(2), .forefront-section td:nth-child(2),
.attachments-section th:nth-child(2), .attachments-section td:nth-child(2) { /* Value/Type */
    width: 30%;
}
.attachments-section th:nth-child(3), .attachments-section td:nth-child(3) { /* Download */
    width: 30%;
}

@media (max-width: 768px) {
    body {
        flex-direction: column;
    }

    .sidebar-container {
        width: 100%;
    }

    .sidebar {
        width: 100%;
        max-width: none;
        min-width: 0;
    }

    .resize-handle {
        display: none;
    }

    .main {
        width: 100%;
    }

    table, thead, tbody, th, td, tr {
        display: block;
    }
    th, td {
        width: 100% !important;
        min-width: 0;
        box-sizing: border-box;
    }
    th::before {
        content: attr(data-label);
        font-weight: normal;
        display: inline-block;
        width: 40%;
    }
    td::before {
        content: attr(data-label);
        font-weight: normal;
        display: inline-block;
        width: 40%;
    }

    .spf-status, .dkim-status, .dmarc-status, .forefront-status, .bcl-status {
        width: calc(100% - 20px);
    }

    .header-section table,
    .header-section thead,
    .header-section tbody,
    .header-section th,
    .header-section td,
    .header-section tr {
        display: block;
    }
    .header-section th,
    .header-section td {
        width: 100% !important;
        min-width: 0;
    }
}

.auth-results-section {
    background-color: #ffffff;
    padding: 20px;
    border-radius: 5px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    margin-bottom: 20px;
}

.auth-results-section h3 {
    color: #333;
    margin-bottom: 15px;
}

.auth-results-section table {
    margin-bottom: 0;
}

.auth-results-status {
    padding: 10px;
    margin-bottom: 10px;
    border-radius: 5px;
    color: white;
    font-weight: bold;
    text-align: center;
    display: inline-block;
    width: calc(100% - 30px);
}

.auth-results-pass {
    background-color: #28a745;
}

.auth-results-fail {
    background-color: #dc3545;
}

.auth-results-details-container {
    display: none;
    margin-top: 10px;
}

.auth-results-details-container.expanded {
    display: block;
}

.toggle-auth-results-arrow {
    cursor: pointer;
    font-size: 14px;
    margin-left: 10px;
    vertical-align: middle;
    color: #333;
    transition: color 0.3s;
}

.toggle-auth-results-arrow:hover {
    color: #007bff;
}

.auth-results-status-container {
    display: flex;
    align-items: center;
    margin-bottom: 10px;
}

.auth-results-details {
    white-space: pre-wrap;
    word-wrap: break-word;
}
        
    </style>
</head>
<body>
    <div class="sidebar-container">
        <div class="sidebar">
            <h2>Email Analyser</h2>
            <textarea id="headerInput" placeholder="Paste email headers and body here..."></textarea>
            <button id="analyseBtn">Analyse</button>
            <button id="clearBtn">Clear</button>
            <footer style="text-align: center; font-size: 10px; color: #6b7280; padding-top: 10px;">
                <a href="https://www.buymeacoffee.com/mrr3b00t" target="_blank">
                    <img src="https://cdn.buymeacoffee.com/buttons/v2/default-yellow.png" alt="Buy Me A Coffee" style="height: 60px !important;width: 217px !important;">
                </a>
                <p>© Xservus Limited</p>
                <p>Version 0.2</p>
            </footer>
        </div>
        <div class="resize-handle"></div>
    </div>
    <div class="main">
        <h2>Email Details</h2>
        <div id="emailDetails"></div>
        <h2>Header Analysis</h2>
        <div id="headerResults"></div>
        <h3>Body Content</h3>
        <div id="bodyResults" class="body-section"></div>
        <h3>Attachments</h3>
        <div id="attachmentResults" class="attachments-section"></div>
        <h2>IOCs</h2>
        <div id="iocResults" class="ioc-section"></div>
    </div>

    <script>
        // Sidebar resizing logic
        const sidebar = document.querySelector('.sidebar');
        const resizeHandle = document.querySelector('.resize-handle');
        let isResizing = false;

        if (resizeHandle && sidebar) {
            resizeHandle.addEventListener('mousedown', (e) => {
                isResizing = true;
                document.body.style.userSelect = 'none';
            });

            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;
                const newWidth = e.clientX - sidebar.getBoundingClientRect().left;
                if (newWidth >= 200 && newWidth <= 500) {
                    sidebar.style.width = `${newWidth}px`;
                }
            });

            document.addEventListener('mouseup', () => {
                if (isResizing) {
                    isResizing = false;
                    document.body.style.userSelect = '';
                }
            });
        }

        // Analysis and sorting logic
        const analyseBtn = document.getElementById('analyseBtn');
        const clearBtn = document.getElementById('clearBtn');
        if (analyseBtn) analyseBtn.addEventListener('click', analyseEmail);
        if (clearBtn) clearBtn.addEventListener('click', clearResults);

        // Global state
        let sortState = { column: 'order', direction: 'asc' };
        let transactions = [];
        let headerFields = {};
        let isHeaderTableExpanded = false;
        let isBodyContentExpanded = false;
        let isBclDetailsExpanded = false;
        let lastSpfResult = {
            status: 'N/A',
            fields: {
                Result: '', Receiver: '', ClientIP: '', EnvelopeFrom: '',
                HELO: '', Mechanism: '', PriorityProtocol: ''
            },
            details: ''
        };
        let lastBclResult = { status: 'N/A', value: '', message: '', details: '' };
        let lastForefrontResult = {
            status: 'N/A',
            fields: {
                CIP: '', CTRY: '', LANG: '', SCL: '', SRV: '', IPV: '',
                SFV: '', H: '', PTR: '', CAT: '', SFS: '', DIR: ''
            },
            details: ''
        };
        let lastBodyContent = '';
        let attachments = [];
        let lastDkimResult = {
        status: 'N/A',
        fields: {
            Result: '', Selector: '', Domain: '', SigningAlgorithm: '',
            Canonicalization: '', SignatureValue: ''
        },
        details: ''
    };

    let lastAuthResults = {
    status: 'N/A',
    fields: {
        SPFResult: '', DKIMResult: '', DMARCResult: '', Server: '', AuthDetails: ''
    },
    details: ''
};

    let lastDmarcResult = {
        status: 'N/A',
        fields: {
            Result: '', FromDomain: '', Policy: '', SubdomainPolicy: '',
            AlignmentDKIM: '', AlignmentSPF: ''
        },
        details: ''
    };

 //DKIM Analysis

 function analyseDKIMRecord(headers) {
    if (typeof headers !== 'string') {
        return {
            status: 'N/A',
            fields: {
                Result: '', Selector: '', Domain: '', SigningAlgorithm: '',
                Canonicalization: '', SignatureValue: ''
            },
            details: 'Headers must be a string'
        };
    }

    // Initialize default result
    let result = {
        status: 'N/A',
        fields: {
            Result: '', Selector: '', Domain: '', SigningAlgorithm: '',
            Canonicalization: '', SignatureValue: ''
        },
        details: ''
    };

    // Try parsing Authentication-Results header first
    const authResultsRegex = /^Authentication-Results:.*?(?=\n[A-Z-]|$)/gim;
    const authResultsMatches = headers.match(authResultsRegex) || [];
    if (authResultsMatches.length > 0) {
        const authHeader = authResultsMatches[0].trim();
        result.details = authHeader;

        // Extract DKIM fields
        result.fields.Selector = (authHeader.match(/s=([^;]+)/i) || [])[1] || '';
        result.fields.Domain = (authHeader.match(/d=([^;]+)/i) || [])[1] || '';
        result.fields.SigningAlgorithm = (authHeader.match(/a=([^;]+)/i) || [])[1] || '';
        result.fields.Canonicalization = (authHeader.match(/c=([^;]+)/i) || [])[1] || '';
        result.fields.SignatureValue = (authHeader.match(/b=([^;]+)/i) || [])[1] || '';

        // Try to get explicit dkim result
        const dkimResultMatch = authHeader.match(/dkim=(\w+)/i);
        result.fields.Result = dkimResultMatch ? dkimResultMatch[1] : '';

        // If no explicit dkim result, infer based on presence of fields
        if (!result.fields.Result && (result.fields.Selector || result.fields.Domain || result.fields.SigningAlgorithm)) {
            result.fields.Result = 'unknown';
            result.status = 'UNKNOWN'; // Custom status for partial data
        } else if (result.fields.Result) {
            result.status = result.fields.Result.toLowerCase() === 'pass' ? 'PASS' : 'FAIL';
        }
    }

    // If no valid DKIM data from Authentication-Results, try DKIM-Signature
    if (!result.fields.Result && !result.fields.Selector && !result.fields.Domain) {
        const dkimRegex = /^DKIM-Signature:.*?(?=\n[A-Z-]|$)/gim;
        const dkimMatches = headers.match(dkimRegex) || [];
        if (dkimMatches.length === 0) {
            return {
                status: 'N/A',
                fields: {
                    Result: '', Selector: '', Domain: '', SigningAlgorithm: '',
                    Canonicalization: '', SignatureValue: ''
                },
                details: 'No DKIM record found'
            };
        }

        const dkimHeader = dkimMatches[0].trim();
        result.fields.Selector = (dkimHeader.match(/s=([^;]+)/i) || [])[1] || '';
        result.fields.Domain = (dkimHeader.match(/d=([^;]+)/i) || [])[1] || '';
        result.fields.SigningAlgorithm = (dkimHeader.match(/a=([^;]+)/i) || [])[1] || '';
        result.fields.Canonicalization = (dkimHeader.match(/c=([^;]+)/i) || [])[1] || '';
        result.fields.SignatureValue = (dkimHeader.match(/b=([^;]+)/i) || [])[1] || '';
        result.details = dkimHeader;

        // Try to get dkim result from Authentication-Results
        result.fields.Result = authResultsMatches.length > 0 ? (authResultsMatches[0].match(/dkim=(\w+)/i)?.[1] || '') : '';
        if (result.fields.Result) {
            result.status = result.fields.Result.toLowerCase() === 'pass' ? 'PASS' : 'FAIL';
        } else if (result.fields.Selector || result.fields.Domain || result.fields.SigningAlgorithm) {
            result.fields.Result = 'unknown';
            result.status = 'UNKNOWN';
        }
    }

    return result;
}
 //DKIM Analyis End

    function analyseDMARCRecord(headers) {
    // Validate input
    if (typeof headers !== 'string') {
        console.debug('analyseDMARCRecord: Invalid input, headers must be a string:', headers);
        return {
            status: 'N/A',
            fields: {
                Result: 'N/A',
                FromDomain: 'N/A',
                Policy: 'N/A',
                SubdomainPolicy: 'N/A',
                AlignmentDKIM: 'N/A',
                AlignmentSPF: 'N/A'
            },
            details: 'Headers must be a string'
        };
    }

    // Log input for debugging
    console.debug('analyseDMARCRecord: Input headers:', headers);

    // Normalize whitespace (replace tabs and multiple spaces with single space, preserve newlines)
    const normalizedHeaders = headers.replace(/\t+/g, ' ').replace(/ +/g, ' ').trim();

    // Find all Authentication-Results headers
    const authResultsRegex = /(?:^|\n)Authentication-Results:[^\n]*(?:\n\s+[^\n]*)*?(?=\n[^ \t\n]|\n*$)/gi;
    const authMatches = normalizedHeaders.match(authResultsRegex) || [];

    if (authMatches.length === 0) {
        console.debug('analyseDMARCRecord: No Authentication-Results header found in:', normalizedHeaders);
        return {
            status: 'N/A',
            fields: {
                Result: 'N/A',
                FromDomain: 'N/A',
                Policy: 'N/A',
                SubdomainPolicy: 'N/A',
                AlignmentDKIM: 'N/A',
                AlignmentSPF: 'N/A'
            },
            details: 'No DMARC record found'
        };
    }

    // Use the last Authentication-Results header (closest to receiving server)
    const dmarcHeader = authMatches[authMatches.length - 1].replace(/^Authentication-Results:\s*/, '').trim();
    console.debug('analyseDMARCRecord: Selected header:', dmarcHeader);

    // Extract fields with case-insensitive regex
    const fields = {
        Result: (dmarcHeader.match(/dmarc=(\w+)/i) || [])[1]?.toLowerCase() || 'N/A',
        FromDomain: (dmarcHeader.match(/header\.from=([^;\s]+)/i) || [])[1] || 'N/A',
        Policy: (dmarcHeader.match(/p=([^;\s]+)/i) || [])[1] || 'N/A',
        SubdomainPolicy: (dmarcHeader.match(/sp=([^;\s]+)/i) || [])[1] || 'N/A',
        AlignmentDKIM: (dmarcHeader.match(/dkim-alignment=([^;\s]+)/i) || [])[1] || 'N/A',
        AlignmentSPF: (dmarcHeader.match(/spf-alignment=([^;\s]+)/i) || [])[1] || 'N/A'
    };

    // Determine status based on Result
    let status = 'N/A';
    if (fields.Result !== 'N/A') {
        if (['pass', 'fail', 'none'].includes(fields.Result)) {
            status = fields.Result === 'pass' ? 'PASS' : 'FAIL';
        } else {
            status = 'INVALID';
        }
    }

    // Provide detailed feedback
    let details = `DMARC result: ${fields.Result}`;
    if (fields.Result === 'N/A') {
        details = 'No DMARC record found';
    } else if (fields.Policy !== 'N/A') {
        details += `, policy: ${fields.Policy}`;
    }

    console.debug('analyseDMARCRecord: Output:', { status, fields, details });

    return {
        status,
        fields,
        details
    };
}

    function toggleDkimDetails() {
        const dkimDetails = document.getElementById('dkim-details');
        const toggleArrow = document.querySelector('.toggle-dkim-arrow');
        if (dkimDetails && toggleArrow) {
            dkimDetails.classList.toggle('expanded');
            toggleArrow.textContent = dkimDetails.classList.contains('expanded') ? '▲' : '▼';
        }
    }

    function toggleDmarcDetails() {
        const dmarcDetails = document.getElementById('dmarc-details');
        const toggleArrow = document.querySelector('.toggle-dmarc-arrow');
        if (dmarcDetails && toggleArrow) {
            dmarcDetails.classList.toggle('expanded');
            toggleArrow.textContent = dmarcDetails.classList.contains('expanded') ? '▲' : '▼';
        }
    }


        function escapeHtml(text) {
            if (typeof text !== 'string') return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function sanitizeHtml(html) {
            try {
                const div = document.createElement('div');
                div.innerHTML = html;

                ['script', 'iframe', 'object', 'embed'].forEach(tag => {
                    const elements = div.getElementsByTagName(tag);
                    while (elements.length) {
                        elements[0].parentNode.removeChild(elements[0]);
                    }
                });

                const elements = div.querySelectorAll('*');
                elements.forEach(el => {
                    Array.from(el.attributes).forEach(attr => {
                        const name = attr.name.toLowerCase();
                        const value = attr.value.toLowerCase();
                        if (name.startsWith('on') || value.includes('javascript:') || value.includes('data:')) {
                            el.removeAttribute(attr.name);
                        }
                        if (['src'].includes(name) && value.match(/^(https?:\/\/)?[\w.-]*(mzstatic\.com|apple\.com)\//)) {
                            // Keep original src
                        } else if (['src', 'href'].includes(name) && (value.startsWith('http') || value.startsWith('//'))) {
                            el.setAttribute(attr.name, '#');
                        }
                    });
                });

                return div.innerHTML;
            } catch (e) {
                console.error('Error sanitizing HTML:', e);
                return '<p>Error rendering HTML content.</p>';
            }
        }

        function decodeQuotedPrintable(text) {
            if (typeof text !== 'string') return '';
            let bytes = [];
            text = text.replace(/=\r?\n/g, '');
            let i = 0;
            while (i < text.length) {
                if (text[i] === '=' && i + 2 < text.length) {
                    const hex = text.slice(i + 1, i + 3);
                    if (/[0-9A-F]{2}/i.test(hex)) {
                        bytes.push(parseInt(hex, 16));
                        i += 3;
                    } else {
                        bytes.push(text.charCodeAt(i));
                        i++;
                    }
                } else {
                    bytes.push(text.charCodeAt(i));
                    i++;
                }
            }
            try {
                return new TextDecoder('utf-8').decode(new Uint8Array(bytes));
            } catch (e) {
                console.warn('UTF-8 decoding failed:', e);
                return text;
            }
        }

        function decodeBase64(text) {
            if (typeof text !== 'string') return '';
            try {
                const cleanedText = text.replace(/\s+/g, '');
                const base64Regex = /^[A-Za-z0-9+/=]+$/;
                if (!base64Regex.test(cleanedText)) {
                    console.warn('Invalid base64 string detected:', cleanedText.substring(0, 50) + '...');
                    return '';
                }
                const paddingNeeded = (4 - (cleanedText.length % 4)) % 4;
                const paddedText = cleanedText + '='.repeat(paddingNeeded);
                const decoded = atob(paddedText);
                return decoded;
            } catch (e) {
                console.warn('Failed to decode base64 string:', e.message);
                return '';
            }
        }

        function parseEmailAddress(emailStr) {
            if (typeof emailStr !== 'string') return '';
            const match = emailStr.match(/<([^>]+)>|[^\s<>,;]+@[^\s<>,;]+/);
            return match ? match[1] || match[0] : '';
        }

        function escapeRegex(str) {
            if (typeof str !== 'string') return '';
            return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        function validateIP(ip) {
            if (typeof ip !== 'string') return '';
            const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
            const ipv6Regex = /^[0-9a-fA-F:]+$/;
            return ipv4Regex.test(ip) || (ipv6Regex.test(ip) && ip.includes(':')) ? ip : '';
        }

        function parseDate(dateStr) {
            if (!dateStr || typeof dateStr !== 'string') return '';
            let cleanedDate = dateStr.replace(/^;?\s*|\s*;?\s*$/g, '').replace(/\s+/g, ' ').trim();
            const parts = cleanedDate.match(/(?:(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s*)?(\d{1,2})\s+(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+(\d{4})\s+(\d{2}:\d{2}:\d{2})\s*(?:(?:[+-]\d{4}|GMT|UTC|Z|\w+)?)?/i);
            if (!parts) return '';

            let [, day, month, year, time, tz] = parts;
            const months = {
                'jan': '01', 'feb': '02', 'mar': '03', 'apr': '04',
                'may': '05', 'jun': '06', 'jul': '07', 'aug': '08',
                'sep': '09', 'oct': '10', 'nov': '11', 'dec': '12'
            };

            day = day.padStart(2, '0');
            month = months[month.toLowerCase()];
            if (!month) return '';

            tz = tz ? tz.trim() : '+0000';
            if (['GMT', 'UTC', 'Z'].includes(tz.toUpperCase())) {
                tz = '+0000';
            } else if (!tz.match(/^[+-]\d{4}$/)) {
                tz = '+0000';
            } else {
                tz = tz.replace(/([+-]\d{2})(\d{2})/, '$1:$2');
            }

            const dateString = `${year}-${month}-${day}T${time}${tz}`;
            try {
                const date = new Date(dateString);
                return isNaN(date.getTime()) ? '' : date.toISOString();
            } catch (e) {
                console.error('Date parsing error:', e, dateString);
                return '';
            }
        }

        function analyseSPFRecord(headers) {
            if (typeof headers !== 'string') {
                return {
                    status: 'N/A',
                    fields: {
                        Result: '', Receiver: '', ClientIP: '', EnvelopeFrom: '',
                        HELO: '', Mechanism: '', PriorityProtocol: ''
                    },
                    details: 'Headers must be a string'
                };
            }
            const spfRegex = /^Received-SPF:.*?(?=\n[A-Z-]|$)/gim;
            const spfMatches = headers.match(spfRegex) || [];
            if (spfMatches.length === 0) {
                return {
                    status: 'N/A',
                    fields: {
                        Result: '', Receiver: '', ClientIP: '', EnvelopeFrom: '',
                        HELO: '', Mechanism: '', PriorityProtocol: ''
                    },
                    details: 'SPF header is missing'
                };
            }

            const spfHeader = spfMatches[0].trim();
            const fields = {
                Result: (spfHeader.match(/^Received-SPF: (\w+)/i) || [])[1] || '',
                Receiver: (spfHeader.match(/receiver=([^;]+)/i) || [])[1] || '',
                ClientIP: (spfHeader.match(/client-ip=([^;]+)/i) || [])[1] || '',
                EnvelopeFrom: (spfHeader.match(/envelope-from=([^;]+)/i) || 
                              spfHeader.match(/domain of\s*<?([^;>\s]+)/i) || [])[1] || '',
                HELO: (spfHeader.match(/helo=([^;]+)/i) || [])[1] || '',
                Mechanism: (spfHeader.match(/mechanism=([^;]+)/i) || 
                           spfHeader.match(/problem=([^;]+)/i) || [])[1] || '',
                PriorityProtocol: (spfHeader.match(/pr=([^;]+)/i) || [])[1] || ''
            };

            return {
                status: fields.Result.toLowerCase() === 'pass' ? 'PASS' : 'FAIL',
                fields,
                details: spfHeader
            };
        }

        function analyseBCLRecord(headers) {
            if (typeof headers !== 'string') {
                return {
                    status: 'N/A',
                    value: '',
                    message: 'Invalid headers provided',
                    details: 'Headers must be a string'
                };
            }
            const bclRegex = /^X-Microsoft-Antispam:.*$/gim;
            const bclMatches = headers.match(bclRegex) || [];
            if (bclMatches.length === 0) {
                return {
                    status: 'N/A',
                    value: '',
                    message: 'No X-Microsoft-Antispam header found',
                    details: 'X-Microsoft-Antispam header is missing'
                };
            }

            const bclHeader = bclMatches[0].replace(/^X-Microsoft-Antispam:\s*/i, '').trim();
            const bclValueMatch = bclHeader.match(/BCL:(\d+)/i);
            if (!bclValueMatch) {
                return {
                    status: 'N/A',
                    value: '',
                    message: 'BCL value not found in header',
                    details: bclHeader
                };
            }

            const bclValue = parseInt(bclValueMatch[1], 10);
            let status, message;
            if (bclValue <= 3) {
                status = 'LOW';
                message = 'Low bulk complaint level - email is unlikely to be spam';
            } else if (bclValue <= 6) {
                status = 'MEDIUM';
                message = 'Medium bulk complaint level - email may be spam';
            } else {
                status = 'HIGH';
                message = 'High bulk complaint level - email is likely spam';
            }

            return {
                status,
                value: bclValue.toString(),
                message,
                details: bclHeader
            };
        }

        function analyseForefrontAntispam(headers) {
            if (typeof headers !== 'string') {
                return {
                    status: 'N/A',
                    fields: {
                        CIP: '', CTRY: '', LANG: '', SCL: '', SRV: '', IPV: '',
                        SFV: '', H: '', PTR: '', CAT: '', SFS: '', DIR: ''
                    },
                    details: 'Headers must be a string'
                };
            }
            const forefrontRegex = /^X-Forefront-Antispam-Report:.*$/gim;
            const forefrontMatches = headers.match(forefrontRegex) || [];
            if (forefrontMatches.length === 0) {
                return {
                    status: 'N/A',
                    fields: {
                        CIP: '', CTRY: '', LANG: '', SCL: '', SRV: '', IPV: '',
                        SFV: '', H: '', PTR: '', CAT: '', SFS: '', DIR: ''
                    },
                    details: 'X-Forefront-Antispam-Report header is missing'
                };
            }

            const forefrontHeader = forefrontMatches[0].replace(/^X-Forefront-Antispam-Report:\s*/i, '').trim();
            const fields = {
                CIP: (forefrontHeader.match(/CIP:([^;]+)/i) || [])[1] || '',
                CTRY: (forefrontHeader.match(/CTRY:([^;]+)/i) || [])[1] || '',
                LANG: (forefrontHeader.match(/LANG:([^;]+)/i) || [])[1] || '',
                SCL: (forefrontHeader.match(/SCL:([^;]+)/i) || [])[1] || '',
                SRV: (forefrontHeader.match(/SRV:([^;]+)/i) || [])[1] || '',
                IPV: (forefrontHeader.match(/IPV:([^;]+)/i) || [])[1] || '',
                SFV: (forefrontHeader.match(/SFV:([^;]+)/i) || [])[1] || '',
                H: (forefrontHeader.match(/H:([^;]+)/i) || [])[1] || '',
                PTR: (forefrontHeader.match(/PTR:([^;]+)/i) || [])[1] || '',
                CAT: (forefrontHeader.match(/CAT:([^;]+)/i) || [])[1] || '',
                SFS: (forefrontHeader.match(/SFS:([^;]+)/i) || [])[1] || '',
                DIR: (forefrontHeader.match(/DIR:([^;]+)/i) || [])[1] || ''
            };

            return {
                status: 'VALID',
                fields,
                details: forefrontHeader
            };
        }

        function sortTransactions(column, direction) {
            transactions.sort((a, b) => {
                let valA = a[column] || '';
                let valB = b[column] || '';

                if (column === 'order') {
                    valA = parseInt(valA) || 0;
                    valB = parseInt(valB) || 0;
                    return direction === 'asc' ? valA - valB : valB - valA;
                }

                if (column === 'timestamp') {
                    valA = valA ? new Date(valA) : new Date(0);
                    valB = valB ? new Date(valB) : new Date(0);
                    return direction === 'asc' ? valA - valB : valB - valA;
                }

                if (!valA && !valB) return 0;
                if (!valA) return direction === 'asc' ? 1 : -1;
                if (!valB) return direction === 'asc' ? -1 : 1;
                return direction === 'asc'
                    ? valA.localeCompare(valB)
                    : valB.localeCompare(valA);
            });
        }

// Render Header Fields

function renderHeaderFields(headerFields, spfResult, dkimResult, dmarcResult, bclResult, forefrontResult, authResult) {
    let html = '<div class="header-fields" style="margin-bottom: 20px;">';
    
    // SPF Section
    html += `
        <div class="spf-section">
            ${spfResult.status === 'N/A' ? 
                '<div class="spf-status-container"><div class="spf-status spf-fail">SPF: N/A</div></div><p>No SPF record found.</p>' : 
                `<div class="spf-status-container">
                    <div class="spf-status ${spfResult.status === 'PASS' ? 'spf-pass' : 'spf-fail'}">
                        SPF: ${escapeHtml(spfResult.fields.Result || 'N/A')}
                    </div>
                    <span class="toggle-spf-arrow" onclick="toggleSpfDetails()">▼</span>
                </div>
                <div class="spf-details-container" id="spf-details">
                    <h3>SPF Analysis</h3>
                    <table>
                        <thead>
                            <tr>
                                <th data-label="Field">Field</th>
                                <th data-label="Value">Value</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr><td data-label="Result">Result</td><td data-label="Value">${escapeHtml(spfResult.fields.Result || 'N/A')}</td></tr>
                            <tr><td data-label="Receiver">Receiver</td><td data-label="Value">${escapeHtml(spfResult.fields.Receiver || 'N/A')}</td></tr>
                            <tr><td data-label="Client IP">Client IP</td><td data-label="Value">${escapeHtml(spfResult.fields.ClientIP || 'N/A')}</td></tr>
                            <tr><td data-label="Envelope From">Envelope From</td><td data-label="Value">${escapeHtml(spfResult.fields.EnvelopeFrom || 'N/A')}</td></tr>
                            <tr><td data-label="HELO">HELO</td><td data-label="Value">${escapeHtml(spfResult.fields.HELO || 'N/A')}</td></tr>
                            <tr><td data-label="Mechanism">Mechanism</td><td data-label="Value">${escapeHtml(spfResult.fields.Mechanism || 'N/A')}</td></tr>
                            <tr><td data-label="Priority/Protocol">Priority/Protocol</td><td data-label="Value">${escapeHtml(spfResult.fields.PriorityProtocol || 'N/A')}</td></tr>
                        </tbody>
                    </table>
                    <p style="margin-top: 10px;" class="spf-details"><strong>Full Details:</strong> ${escapeHtml(spfResult.details)}</p>
                </div>`
            }
        </div>
    `;
    
    // DKIM Section
    html += `
        <div class="dkim-section">
            ${dkimResult.status === 'N/A' ? 
                '<div class="dkim-status-container"><div class="dkim-status dkim-fail">DKIM: N/A</div></div><p>No DKIM record found.</p>' : 
                `<div class="dkim-status-container">
                    <div class="dkim-status ${dkimResult.status === 'PASS' ? 'dkim-pass' : dkimResult.status === 'UNKNOWN' ? 'dkim-fail' : 'dkim-fail'}">
                        DKIM: ${escapeHtml(dkimResult.fields.Result || 'N/A')}
                    </div>
                    <span class="toggle-dkim-arrow" onclick="toggleDkimDetails()">▼</span>
                </div>
                <div class="dkim-details-container" id="dkim-details">
                    <h3>DKIM Analysis</h3>
                    <table>
                        <thead>
                            <tr>
                                <th data-label="Field">Field</th>
                                <th data-label="Value">Value</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr><td data-label="Result">Result</td><td data-label="Value">${escapeHtml(dkimResult.fields.Result || 'N/A')}</td></tr>
                            <tr><td data-label="Selector">Selector</td><td data-label="Value">${escapeHtml(dkimResult.fields.Selector || 'N/A')}</td></tr>
                            <tr><td data-label="Domain">Domain</td><td data-label="Value">${escapeHtml(dkimResult.fields.Domain || 'N/A')}</td></tr>
                            <tr><td data-label="Signing Algorithm">Signing Algorithm</td><td data-label="Value">${escapeHtml(dkimResult.fields.SigningAlgorithm || 'N/A')}</td></tr>
                            <tr><td data-label="Canonicalization">Canonicalization</td><td data-label="Value">${escapeHtml(dkimResult.fields.Canonicalization || 'N/A')}</td></tr>
                            <tr><td data-label="Signature Value">Signature Value</td><td data-label="Value">${escapeHtml(dkimResult.fields.SignatureValue || 'N/A')}</td></tr>
                        </tbody>
                    </table>
                    <p style="margin-top: 10px;" class="dkim-details"><strong>Full Details:</strong> ${escapeHtml(dkimResult.details)}</p>
                </div>`
            }
        </div>
    `;
    
    // DMARC Section
    html += `
        <div class="dmarc-section">
            ${dmarcResult.status === 'N/A' ? 
                '<div class="dmarc-status-container"><div class="dmarc-status dmarc-fail">DMARC: N/A</div></div><p>No DMARC record found.</p>' : 
                `<div class="dmarc-status-container">
                    <div class="dmarc-status ${dmarcResult.status === 'PASS' ? 'dmarc-pass' : 'dmarc-fail'}">
                        DMARC: ${escapeHtml(dmarcResult.fields.Result || 'N/A')}
                    </div>
                    <span class="toggle-dmarc-arrow" onclick="toggleDmarcDetails()">▼</span>
                </div>
                <div class="dmarc-details-container" id="dmarc-details">
                    <h3>DMARC Analysis</h3>
                    <table>
                        <thead>
                            <tr>
                                <th data-label="Field">Field</th>
                                <th data-label="Value">Value</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr><td data-label="Result">Result</td><td data-label="Value">${escapeHtml(dmarcResult.fields.Result || 'N/A')}</td></tr>
                            <tr><td data-label="From Domain">From Domain</td><td data-label="Value">${escapeHtml(dmarcResult.fields.FromDomain || 'N/A')}</td></tr>
                            <tr><td data-label="Policy">Policy</td><td data-label="Value">${escapeHtml(dmarcResult.fields.Policy || 'N/A')}</td></tr>
                            <tr><td data-label="Subdomain Policy">Subdomain Policy</td><td data-label="Value">${escapeHtml(dmarcResult.fields.SubdomainPolicy || 'N/A')}</td></tr>
                            <tr><td data-label="DKIM Alignment">DKIM Alignment</td><td data-label="Value">${escapeHtml(dmarcResult.fields.AlignmentDKIM || 'N/A')}</td></tr>
                            <tr><td data-label="SPF Alignment">SPF Alignment</td><td data-label="Value">${escapeHtml(dmarcResult.fields.AlignmentSPF || 'N/A')}</td></tr>
                        </tbody>
                    </table>
                    <p style="margin-top: 10px;" class="dmarc-details"><strong>Full Details:</strong> ${escapeHtml(dmarcResult.details)}</p>
                </div>`
            }
        </div>
    `;
    
    // Authentication-Results Section
    html += `
        <div class="auth-results-section">
            ${authResult.status === 'N/A' ? 
                '<div class="auth-results-status-container"><div class="auth-results-status auth-results-fail">Authentication-Results: N/A</div></div><p>No Authentication-Results header found.</p>' : 
                `<div class="auth-results-status-container">
                    <div class="auth-results-status ${authResult.status === 'PASS' ? 'auth-results-pass' : 'auth-results-fail'}">
                        Authentication-Results: ${escapeHtml(authResult.status)}
                    </div>
                    <span class="toggle-auth-results-arrow" onclick="toggleAuthResultsDetails()">▼</span>
                </div>
                <div class="auth-results-details-container" id="auth-results-details">
                    <h3>Authentication-Results Analysis</h3>
                    <table>
                        <thead>
                            <tr>
                                <th data-label="Field">Field</th>
                                <th data-label="Value">Value</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr><td data-label="SPF Result">SPF Result</td><td data-label="Value">${escapeHtml(authResult.fields.SPFResult || 'N/A')}</td></tr>
                            <tr><td data-label="DKIM Result">DKIM Result</td><td data-label="Value">${escapeHtml(authResult.fields.DKIMResult || 'N/A')}</td></tr>
                            <tr><td data-label="DMARC Result">DMARC Result</td><td data-label="Value">${escapeHtml(authResult.fields.DMARCResult || 'N/A')}</td></tr>
                            <tr><td data-label="Server">Server</td><td data-label="Value">${escapeHtml(authResult.fields.Server || 'N/A')}</td></tr>
                            <tr><td data-label="Auth Details">Auth Details</td><td data-label="Value">${escapeHtml(authResult.fields.AuthDetails || 'N/A')}</td></tr>
                        </tbody>
                    </table>
                    <p style="margin-top: 10px;" class="auth-results-details"><strong>Full Details:</strong> ${escapeHtml(authResult.details)}</p>
                </div>`
            }
        </div>
    `;
    
    // BCL Section
    html += `
        <div class="bcl-section">
            ${bclResult.status === 'N/A' ? 
                '<div class="bcl-status-container"><div class="bcl-status bcl-na">X-Microsoft-Antispam: N/A</div></div><p>No X-Microsoft-Antispam header found.</p>' : 
                `<div class="bcl-status-container">
                    <div class="bcl-status ${bclResult.status === 'LOW' ? 'bcl-low' : bclResult.status === 'MEDIUM' ? 'bcl-medium' : 'bcl-high'}">
                        X-Microsoft-Antispam: ${escapeHtml(bclResult.status)}
                    </div>
                    <span class="toggle-bcl-arrow" onclick="toggleBclDetails()">▼</span>
                </div>
                <div class="bcl-details-container" id="bcl-details">
                    <h3>BCL Analysis</h3>
                    <table>
                        <thead>
                            <tr>
                                <th data-label="Field">Field</th>
                                <th data-label="Value">Value</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr><td data-label="Status">Status</td><td data-label="Value">${escapeHtml(bclResult.status)}</td></tr>
                            <tr><td data-label="BCL Value">BCL Value</td><td data-label="Value">${escapeHtml(bclResult.value || 'N/A')}</td></tr>
                            <tr><td data-label="Message">Message</td><td data-label="Value">${escapeHtml(bclResult.message)}</td></tr>
                        </tbody>
                    </table>
                    <p style="margin-top: 10px;" class="bcl-details"><strong>Full Details:</strong> ${escapeHtml(bclResult.details)}</p>
                </div>`
            }
        </div>
    `;
    
    // Forefront Antispam Section
    html += `
        <div class="forefront-section">
            ${forefrontResult.status === 'N/A' ? 
                '<div class="forefront-status-container"><div class="forefront-status na">X-Forefront-Antispam-Report: N/A</div></div><p>No X-Forefront-Antispam-Report header found.</p>' : 
                `<div class="forefront-status-container">
                    <div class="forefront-status">
                        X-Forefront-Antispam-Report: ${escapeHtml(forefrontResult.status)}
                    </div>
                    <span class="toggle-forefront-arrow" onclick="toggleForefrontDetails()">▼</span>
                </div>
                <div class="forefront-details-container" id="forefront-details">
                    <h3>X-Forefront-Antispam-Report Analysis</h3>
                    <table>
                        <thead>
                            <tr>
                                <th data-label="Field">Field</th>
                                <th data-label="Value">Value</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr><td data-label="Language">Language</td><td data-label="Value">${escapeHtml(forefrontResult.fields.LANG || 'N/A')}</td></tr>
                            <tr><td data-label="Spam Confidence Level">Spam Confidence Level</td><td data-label="Value">${escapeHtml(forefrontResult.fields.SCL || 'N/A')}</td></tr>
                            <tr><td data-label="Spam Filtering Verdict">Spam Filtering Verdict</td><td data-label="Value">${escapeHtml(forefrontResult.fields.SFV || 'N/A')}</td></tr>
                            <tr><td data-label="IP Filter Verdict">IP Filter Verdict</td><td data-label="Value">${escapeHtml(forefrontResult.fields.IPV || 'N/A')}</td></tr>
                            <tr><td data-label="HELO/EHLO">HELO/EHLO</td><td data-label="Value">${escapeHtml(forefrontResult.fields.H || 'N/A')}</td></tr>
                            <tr><td data-label="PTR Record">PTR Record</td><td data-label="Value">${escapeHtml(forefrontResult.fields.PTR || 'N/A')}</td></tr>
                            <tr><td data-label="Connecting IP Address">Connecting IP Address</td><td data-label="Value">${escapeHtml(forefrontResult.fields.CIP || 'N/A')}</td></tr>
                            <tr><td data-label="Protection Policy Category">Protection Policy Category</td><td data-label="Value">${escapeHtml(forefrontResult.fields.CAT || 'N/A')}</td></tr>
                            <tr><td data-label="Spam Rules">Spam Rules</td><td data-label="Value">${escapeHtml(forefrontResult.fields.SFS || 'N/A')}</td></tr>
                            <tr><td data-label="Source Header">Source Header</td><td data-label="Value">${escapeHtml(forefrontResult.fields.SRV || 'N/A')}</td></tr>
                            <tr><td data-label="Direction">Direction</td><td data-label="Value">${escapeHtml(forefrontResult.fields.DIR || 'N/A')}</td></tr>
                        </tbody>
                    </table>
                    <p style="margin-top: 10px;" class="forefront-details"><strong>Full Details:</strong> ${escapeHtml(forefrontResult.details)}</p>
                </div>`
            }
        </div>
    `;
    
    html += '</div>';
    return html;
}


// ENd of Render Header Fields

        function toggleSpfDetails() {
            const spfDetails = document.getElementById('spf-details');
            const toggleArrow = document.querySelector('.toggle-spf-arrow');
            if (spfDetails && toggleArrow) {
                spfDetails.classList.toggle('expanded');
                toggleArrow.textContent = spfDetails.classList.contains('expanded') ? '▲' : '▼';
            }
        }

        function toggleForefrontDetails() {
            const forefrontDetails = document.getElementById('forefront-details');
            const toggleArrow = document.querySelector('.toggle-forefront-arrow');
            if (forefrontDetails && toggleArrow) {
                forefrontDetails.classList.toggle('expanded');
                toggleArrow.textContent = forefrontDetails.classList.contains('expanded') ? '▲' : '▼';
            }
        }

        function toggleBclDetails() {
            isBclDetailsExpanded = !isBclDetailsExpanded;
            const bclDetails = document.getElementById('bcl-details');
            const toggleArrow = document.querySelector('.toggle-bcl-arrow');
            if (bclDetails && toggleArrow) {
                bclDetails.classList.toggle('expanded');
                toggleArrow.textContent = bclDetails.classList.contains('expanded') ? '▲' : '▼';
            }
        }

  

        function toggleBodyContent() {
            isBodyContentExpanded = !isBodyContentExpanded;
            const bodyResultsDiv = document.getElementById('bodyResults');
            if (!bodyResultsDiv) return;

            let bodyHtml = '';
            if (lastBodyContent) {
                bodyHtml += `<div class="body-content-toggle">
                    <span class="toggle-body-arrow" onclick="toggleBodyContent()">${isBodyContentExpanded ? '▲' : '▼'}</span>
                </div>
                <div class="body-content-container${isBodyContentExpanded ? ' expanded' : ''}" id="body-content">
                    ${lastBodyContent}
                </div>`;
            } else {
                bodyHtml = '<p>No body content provided.</p>';
            }
            bodyResultsDiv.innerHTML = bodyHtml;
        }

        function renderEmailDetails(headerFields) {
            let html = '<div class="email-details" style="margin-bottom: 20px;">';
            html += '<p><strong>From:</strong> ' + (headerFields.from ? escapeHtml(headerFields.from) : 'Not provided') + '</p>';
            html += '<p><strong>To:</strong> ' + (headerFields.to.length ? escapeHtml(headerFields.to.join(', ')) : 'Not provided') + '</p>';
            html += '<p><strong>Cc:</strong> ' + (headerFields.cc.length ? escapeHtml(headerFields.cc.join(', ')) : 'Not provided') + '</p>';
            html += '<p><strong>Subject:</strong> ' + (headerFields.subject ? escapeHtml(headerFields.subject) : 'Not provided') + '</p>';
            html += '<p><strong>Date:</strong> ' + (headerFields.date ? escapeHtml(headerFields.date) : 'Not provided') + '</p>';
            html += '</div>';
            return html;
        }


    // New renderTable function

    function toggleHeaderTable() {
    isHeaderTableExpanded = !isHeaderTableExpanded;
    renderTable(lastSpfResult, lastDkimResult, lastDmarcResult, lastBclResult, lastForefrontResult, lastAuthResults);
}

function renderTable(spfResult, dkimResult, dmarcResult, bclResult, forefrontResult, authResult) {
    const headerResultsDiv = document.getElementById('headerResults');
    const emailDetailsDiv = document.getElementById('emailDetails');
    
    if (!headerResultsDiv || !emailDetailsDiv) {
        console.error('Header results or email details div not found');
        return;
    }

    emailDetailsDiv.innerHTML = renderEmailDetails(headerFields);

    let tableHtml = renderHeaderFields(headerFields, spfResult, dkimResult, dmarcResult, bclResult, forefrontResult, authResult);
    
    // Always render the header section, even if no transactions
    tableHtml += '<div class="header-section">';

    if (transactions.length === 0) {
        tableHtml += '<p>No headers found.</p></div>';
        headerResultsDiv.innerHTML = tableHtml;
        return;
    }

    tableHtml += `
        <table>
            <thead>
                <tr>
                    <th data-column="order" class="${sortState.column === 'order' ? 'sort-' + sortState.direction : ''}" onclick="sortColumn('order')">Order</th>
                    <th data-column="action" class="${sortState.column === 'action' ? 'sort-' + sortState.direction : ''}" onclick="sortColumn('action')">Action</th>
                    <th data-column="timestamp" class="${sortState.column === 'timestamp' ? 'sort-' + sortState.direction : ''}" onclick="sortColumn('timestamp')">Timestamp</th>
                    <th data-column="fromServer" class="${sortState.column === 'fromServer' ? 'sort-' + sortState.direction : ''}" onclick="sortColumn('fromServer')">From Server</th>
                    <th data-column="byServer" class="${sortState.column === 'byServer' ? 'sort-' + sortState.direction : ''}" onclick="sortColumn('byServer')">By Server</th>
                    <th data-column="ip" class="${sortState.column === 'ip' ? 'sort-' + sortState.direction : ''}" onclick="sortColumn('ip')">IP</th>
                    <th data-column="emailOrDomain" class="${sortState.column === 'emailOrDomain' ? 'sort-' + sortState.direction : ''}" onclick="sortColumn('emailOrDomain')">Email/Domain</th>
                    <th data-column="details" class="${sortState.column === 'details' ? 'sort-' + sortState.direction : ''}" onclick="sortColumn('details')">Details</th>
                </tr>
            </thead>
            <tbody>
    `;

    // Render either all transactions or the first 5 based on isHeaderTableExpanded
    const displayTransactions = isHeaderTableExpanded ? transactions : transactions.slice(0, 5);
    displayTransactions.forEach(transaction => {
        tableHtml += `
            <tr>
                <td data-label="Order">${transaction.order || ''}</td>
                <td data-label="Action">${escapeHtml(transaction.action)}</td>
                <td data-label="Timestamp">${escapeHtml(transaction.timestamp || '')}</td>
                <td data-label="From Server">${escapeHtml(transaction.fromServer || '')}</td>
                <td data-label="By Server">${escapeHtml(transaction.byServer || '')}</td>
                <td data-label="IP">${escapeHtml(transaction.ip || '')}</td>
                <td data-label="Email/Domain">${escapeHtml(transaction.emailOrDomain || '')}</td>
                <td data-label="Details">${escapeHtml(transaction.details)}</td>
            </tr>
        `;
    });

    tableHtml += '</tbody></table>';

    // Always show the toggle if there are more than 5 transactions
    if (transactions.length > 5) {
        tableHtml += `
            <div class="header-table-toggle">
                <span class="toggle-header-arrow" onclick="toggleHeaderTable()">${isHeaderTableExpanded ? '▲' : '▼'}</span>
            </div>
        `;
    }

    tableHtml += '</div>';

    headerResultsDiv.innerHTML = tableHtml;
}




        function renderAttachments() {
            const attachmentResultsDiv = document.getElementById('attachmentResults');
            if (!attachmentResultsDiv) {
                console.error('Attachment results div not found');
                return;
            }

            if (!Array.isArray(attachments) || attachments.length === 0) {
                attachmentResultsDiv.innerHTML = '<p>No attachments found.</p>';
                return;
            }

            let tableHtml = `
                <table>
                    <thead>
                        <tr>
                            <th data-label="Name">Name</th>
                            <th data-label="Type">Type</th>
                            <th data-label="Download">Download</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            attachments.forEach((attachment, index) => {
                tableHtml += `
                    <tr>
                        <td data-label="Name">${escapeHtml(attachment.name)}</td>
                        <td data-label="Type">${escapeHtml(attachment.type)}</td>
                        <td data-label="Download"><a href="${attachment.dataUrl}" download="${escapeHtml(attachment.name)}" class="download-btn">Download</a></td>
                    </tr>
                `;
            });

            tableHtml += '</tbody></table>';
            attachmentResultsDiv.innerHTML = tableHtml;
        }

       // Update sortColumn function
       function sortColumn(column) {
    if (sortState.column === column) {
        sortState.direction = sortState.direction === 'asc' ? 'desc' : 'asc';
    } else {
        sortState.column = column;
        sortState.direction = 'asc';
    }
    sortTransactions(sortState.column, sortState.direction);
    renderTable(lastSpfResult, lastDkimResult, lastDmarcResult, lastBclResult, lastForefrontResult, lastAuthResults);
}

        function processIOCs(text, bodyParts) {
            if (typeof text !== 'string' || !Array.isArray(bodyParts)) return [];
            const decodedText = decodeQuotedPrintable(text);
            const patterns = {
                url: /https?:\/\/[^\s/$.?#].[^\s]*/gi,
                ipv4: /\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b/g,
                ipv6: /\b(?:[0-9a-fA-F]{1,4}:){1,7}(?::[0-9a-fA-F]{1,4}|:)\b|\b[0-9a-fA-F]{1,4}::[0-9a-fA-F]{1,4}\b/g,
                subnet: /\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\/(?:[8-9]|[1-2][0-9]|3[0-2])\b/g,
                domain: /(?:[a-zA-Z0-9-_]+\.)+[a-zA-Z0-9-_]+\.[a-zA-Z]{2,}/gi,
                email: /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/g,
                hash: /\b[0-9a-fA-F]{32,64}\b/g,
                timestamp: /\b(?:[0-1][0-9]|2[0-3]|[0-9]):[0-5][0-9]:[0-5][0-9](?:\.\d{1,3})?\b/g,
                messageId: /\b[a-zA-Z0-9-]+\.\d+\.\d+\.\d+\b/g
            };

            const hashRegex = {
                sha256: /^[0-9a-fA-F]{64}$/,
                md5: /^[0-9a-fA-F]{32}$/,
                sha1: /^[0-9a-fA-F]{40}$/
            };

            const commonFileExtensions = new Set([
                'png', 'jpg', 'jpeg', 'gif', 'bmp', 'tif', 'tiff', 'pdf',
                'doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx', 'txt', 'csv',
                'zip', 'rar', '7z', 'exe', 'dll', 'sys', 'bat', 'sh',
                'mp3', 'mp4', 'avi', 'mkv', 'mov', 'wmv', 'flv', 'wav',
                'html', 'css', 'js', 'php', 'asp', 'aspx', 'jsp', 'sql',
                'db', 'bak', 'log', 'tar', 'gz', 'tgz'
            ]);

            let cleanedText = decodedText.replace(patterns.timestamp, '');
            const iocs = {
                url: new Set(),
                ip: new Set(),
                subnet: new Set(),
                domain: new Set(),
                email: new Set(),
                hash: new Set()
            };

            function extractMatches(content, regex, set, transform = v => v) {
                if (typeof content !== 'string') return;
                const matches = content.match(regex) || [];
                matches.forEach(match => {
                    const transformed = transform(match);
                    if (transformed) set.add(transformed);
                });
            }

            extractMatches(cleanedText, patterns.url, iocs.url);
            extractMatches(cleanedText, patterns.ipv4, iocs.ip, v => v.replace(/[\[\]\(\)]/g, ''));
            extractMatches(cleanedText, patterns.ipv6, iocs.ip, v => v.replace(/[\[\]\(\)]/g, ''));
            extractMatches(cleanedText, patterns.subnet, iocs.subnet);
            extractMatches(cleanedText, patterns.email, iocs.email);

            extractMatches(cleanedText, patterns.domain, iocs.domain, domain => {
                const normalized = domain.replace(/\.$/, '');
                const extension = normalized.toLowerCase().split('.').pop();
                return (!iocs.ip.has(normalized) && 
                        !iocs.subnet.has(normalized) && 
                        !commonFileExtensions.has(extension)) ? normalized : null;
            });
            iocs.domain.delete(null);

            const messageIds = new Set(cleanedText.match(patterns.messageId) || []);
            extractMatches(cleanedText, patterns.hash, iocs.hash, hash => {
                if (messageIds.has(hash)) return null;
                if (hashRegex.sha256.test(hash)) return JSON.stringify({ value: hash, type: 'SHA256' });
                if (hashRegex.md5.test(hash)) return JSON.stringify({ value: hash, type: 'MD5' });
                if (hashRegex.sha1.test(hash)) return JSON.stringify({ value: hash, type: 'SHA1' });
                return null;
            });
            iocs.hash.delete(null);

            bodyParts.forEach(part => {
                let content = part.content;
                if (part.encoding === 'quoted-printable') {
                    content = decodeQuotedPrintable(content);
                } else if (part.encoding === 'base64') {
                    content = decodeBase64(content);
                }
                if (typeof content !== 'string' || content === '') return;
                content = content.replace(patterns.timestamp, '');

                extractMatches(content, patterns.url, iocs.url);
                extractMatches(content, patterns.ipv4, iocs.ip, v => v.replace(/[\[\]\(\)]/g, ''));
                extractMatches(content, patterns.ipv6, iocs.ip, v => v.replace(/[\[\]\(\)]/g, ''));
                extractMatches(content, patterns.email, iocs.email);

                extractMatches(content, patterns.domain, iocs.domain, domain => {
                    const normalized = domain.replace(/\.$/, '');
                    const extension = normalized.toLowerCase().split('.').pop();
                    return (!iocs.ip.has(normalized) && 
                            !iocs.subnet.has(normalized) && 
                            !commonFileExtensions.has(extension)) ? normalized : null;
                });
                iocs.domain.delete(null);

                extractMatches(content, patterns.hash, iocs.hash, hash => {
                    if (messageIds.has(hash)) return null;
                    if (hashRegex.sha256.test(hash)) return JSON.stringify({ value: hash, type: 'SHA256' });
                    if (hashRegex.md5.test(hash)) return JSON.stringify({ value: hash, type: 'MD5' });
                    if (hashRegex.sha1.test(hash)) return JSON.stringify({ value: hash, type: 'SHA1' });
                    return null;
                });
                iocs.hash.delete(null);
            });

            const result = [];
            iocs.url.forEach(value => result.push({ type: 'URL', value }));
            iocs.ip.forEach(value => result.push({ type: 'IP', value }));
            iocs.subnet.forEach(value => result.push({ type: 'Subnet', value }));
            iocs.domain.forEach(value => result.push({ type: 'Domain', value }));
            iocs.email.forEach(value => result.push({ type: 'Email', value }));
            iocs.hash.forEach(hash => {
                const { value, type } = JSON.parse(hash);
                result.push({ type: `Hash (${type})`, value });
            });

            return result.sort((a, b) => a.type.localeCompare(b.type));
        }

        function renderIOCs(iocs) {
            const iocResultsDiv = document.getElementById('iocResults');
            if (!iocResultsDiv) {
                console.error('IOC results div not found');
                return;
            }

            if (!Array.isArray(iocs) || iocs.length === 0) {
                iocResultsDiv.innerHTML = '<p>No IOCs found.</p>';
                return;
            }

            let tableHtml = `
                <table>
                    <thead>
                        <tr>
                            <th data-label="Type">Type</th>
                            <th data-label="Value">Value</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            iocs.forEach(ioc => {
                tableHtml += `
                    <tr>
                        <td data-label="Type">${escapeHtml(ioc.type)}</td>
                        <td data-label="Value">${escapeHtml(ioc.value)}</td>
                    </tr>
                `;
            });

            tableHtml += '</tbody></table>';
            iocResultsDiv.innerHTML = tableHtml;
        }

 // Update clearResults function
 function clearResults() {
        const headerInput = document.getElementById('headerInput');
        const headerResultsDiv = document.getElementById('headerResults');
        const emailDetailsDiv = document.getElementById('emailDetails');
        const bodyResultsDiv = document.getElementById('bodyResults');
        const attachmentResultsDiv = document.getElementById('attachmentResults');
        const iocResultsDiv = document.getElementById('iocResults');

        if (headerInput) headerInput.value = '';
        if (headerResultsDiv) headerResultsDiv.innerHTML = '';
        if (emailDetailsDiv) emailDetailsDiv.innerHTML = '';
        if (bodyResultsDiv) bodyResultsDiv.innerHTML = '';
        if (attachmentResultsDiv) attachmentResultsDiv.innerHTML = '';
        if (iocResultsDiv) iocResultsDiv.innerHTML = '';
        transactions = [];
        headerFields = {};
        isHeaderTableExpanded = false;
        isBodyContentExpanded = false;
        isBclDetailsExpanded = false;
        lastBodyContent = '';
        attachments = [];
        lastSpfResult = {
            status: 'N/A',
            fields: {
                Result: '', Receiver: '', ClientIP: '', EnvelopeFrom: '',
                HELO: '', Mechanism: '', PriorityProtocol: ''
            },
            details: ''
        };
        lastDkimResult = {
            status: 'N/A',
            fields: {
                Result: '', Selector: '', Domain: '', SigningAlgorithm: '',
                Canonicalization: '', SignatureValue: ''
            },
            details: ''
        };
        lastDmarcResult = {
            status: 'N/A',
            fields: {
                Result: '', FromDomain: '', Policy: '', SubdomainPolicy: '',
                AlignmentDKIM: '', AlignmentSPF: ''
            },
            details: ''
        };
        lastBclResult = { status: 'N/A', value: '', message: '', details: '' };
        lastForefrontResult = {
            status: 'N/A',
            fields: {
                CIP: '', CTRY: '', LANG: '', SCL: '', SRV: '', IPV: '',
                SFV: '', H: '', PTR: '', CAT: '', SFS: '', DIR: ''
            },
            details: ''
        };
        lastAuthResults = {
    status: 'N/A',
    fields: {
        SPFResult: '', DKIMResult: '', DMARCResult: '', Server: '', AuthDetails: ''
    },
    details: ''
};
    }


    function analyseEmail() {
    const headerInput = document.getElementById('headerInput');
    const headerResultsDiv = document.getElementById('headerResults');
    const emailDetailsDiv = document.getElementById('emailDetails');
    const bodyResultsDiv = document.getElementById('bodyResults');
    const attachmentResultsDiv = document.getElementById('attachmentResults');
    const iocResultsDiv = document.getElementById('iocResults');

    if (!headerInput || !headerResultsDiv || !emailDetailsDiv || !bodyResultsDiv || !attachmentResultsDiv || !iocResultsDiv) {
        console.error('Required DOM elements missing');
        return;
    }

    const input = headerInput.value.trim();
    if (!input) {
        emailDetailsDiv.innerHTML = '<p>Please enter email headers to analyse.</p>';
        headerResultsDiv.innerHTML = '<p>Please enter email headers to analyse.</p>';
        bodyResultsDiv.innerHTML = '<p>No body content provided.</p>';
        attachmentResultsDiv.innerHTML = '<p>No attachments found.</p>';
        iocResultsDiv.innerHTML = '<p>No IOCs found.</p>';
        return;
    }

    try {
        // Normalize line endings and split headers from body
        const normalizedInput = input.replace(/\r\n/g, '\n');
        const headerEndIndex = normalizedInput.indexOf('\n\n');
        const headers = headerEndIndex !== -1 ? normalizedInput.substring(0, headerEndIndex) : normalizedInput;
        const body = headerEndIndex !== -1 ? normalizedInput.substring(headerEndIndex + 2).trim() : '';
        transactions = [];
        headerFields = { from: '', to: [], cc: [], subject: '', date: '' };
        attachments = [];

        // Perform analyses
        lastSpfResult = analyseSPFRecord(headers);
        lastDkimResult = analyseDKIMRecord(headers);
        lastDmarcResult = analyseDMARCRecord(headers);
        lastBclResult = analyseBCLRecord(headers);
        lastForefrontResult = analyseForefrontAntispam(headers);

        // Regular expressions for specific headers
        const fromRegex = /^From:.*?(?=\n[A-Z-]|$)/gim;
        const senderRegex = /^Sender:.*?(?=\n[A-Z-]|$)/gim;
        const toRegex = /^To:.*?(?=\n[A-Z-]|$)/gim;
        const ccRegex = /^Cc:.*?(?=\n[A-Z-]|$)/gim;
        const subjectRegex = /^Subject:.*?(?=\n[A-Z-]|$)/gim;
        const dateRegex = /^Date:.*?(?=\n[A-Z-]|$)/gim;
        const emailRegex = /[^\s<>,;]+@[^\s<>,;]+\.[^\s<>,;]+/g;
        const contentTypeRegex = /Content-Type:.*?(?=\n[A-Z-]|$)/gis;
        const contentEncodingRegex = /Content-Transfer-Encoding:.*?(?=\n[A-Z-]|$)/gis;
        const contentDispositionRegex = /Content-Disposition:.*?(?=\n[A-Z-]|$)/gis;
        const receivedRegex = /^Received:.*?(?=\n[A-Z-]|$|\n\n)(?:\n\s+.*?(?=\n[A-Z-]|$|\n\n))*/gim;
        const receivedDateRegex = /;?\s*(?:(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s*)?\d{1,2}\s+(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+\d{4}\s+\d{2}:\d{2}:\d{2}\s*(?:[+-]\d{4}|GMT)?/i;
        const serverRegex = /by\s+([a-zA-Z0-9:.-]+)/i;
        const fromServerRegex = /from\s+([a-zA-Z0-9:.-]+)/i;
        const ipRegex = /\[(?:(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})|([0-9a-fA-F:]+))\]/;
        const boundaryRegex = /boundary=["']?([^"'\n;]+)["']?/i;
        const forRegex = /for\s+<?([^\s>]+@[^\s>]+)>?/i;
        const filenameRegex = /filename=["']?([^"'\n;]+)["']?/i;

        // Extract header fields
        const fromMatches = headers.match(fromRegex) || [];
        if (fromMatches.length > 0) {
            headerFields.from = parseEmailAddress(fromMatches[0].replace(/^From:\s*/i, '').trim()) || fromMatches[0].replace(/^From:\s*/i, '').trim();
        }

        const senderMatches = headers.match(senderRegex) || [];
        if (senderMatches.length > 0 && !headerFields.from) {
            headerFields.from = parseEmailAddress(senderMatches[0].replace(/^Sender:\s*/i, '').trim()) || senderMatches[0].replace(/^Sender:\s*/i, '').trim();
        }

        const toMatches = headers.match(toRegex) || [];
        toMatches.forEach(match => {
            const emails = match.match(emailRegex) || [];
            headerFields.to.push(...emails);
        });
        headerFields.to = [...new Set(headerFields.to)];

        const ccMatches = headers.match(ccRegex) || [];
        ccMatches.forEach(match => {
            const emails = match.match(emailRegex) || [];
            headerFields.cc.push(...emails);
        });
        headerFields.cc = [...new Set(headerFields.cc)];

        const subjectMatches = headers.match(subjectRegex) || [];
        if (subjectMatches.length > 0) {
            headerFields.subject = decodeQuotedPrintable(subjectMatches[0].replace(/^Subject:\s*/i, '').trim());
        }

        const dateMatches = headers.match(dateRegex) || [];
        if (dateMatches.length > 0) {
            headerFields.date = parseDate(dateMatches[0].replace(/^Date:\s*/i, '').trim());
        }

        // Extract global sender and recipients
        const globalSender = headerFields.from;
        const globalRecipients = headerFields.to;

        // Parse all headers
        let orderCounter = 0;
        const headerLines = headers.split('\n');
        let currentHeader = '';
        let currentValue = [];
        const allHeaders = [];

        headerLines.forEach(line => {
            if (/^[A-Za-z0-9-]+:/.test(line)) {
                if (currentHeader) {
                    allHeaders.push({
                        name: currentHeader,
                        value: currentValue.join('\n').trim()
                    });
                    currentValue = [];
                }
                const [name, ...value] = line.split(':');
                currentHeader = name.trim();
                currentValue.push(value.join(':').trim());
            } else if (currentHeader && /^\s+/.test(line)) {
                currentValue.push(line.trim());
            }
        });

        if (currentHeader) {
            allHeaders.push({
                name: currentHeader,
                value: currentValue.join('\n').trim()
            });
        }

        allHeaders.forEach(header => {
            const headerName = header.name;
            const headerValue = header.value;

            if (headerName.toLowerCase() === 'received') {
                const rawValue = headerValue;
                const cleanedValue = rawValue.replace(/\n\s+/g, ' ').trim();

                let date = '';
                const dateMatch = rawValue.match(receivedDateRegex);
                if (dateMatch) {
                    date = parseDate(dateMatch[0].replace(/^;\s*/, '').trim());
                }

                let fromServer = '';
                const fromServerMatch = rawValue.match(fromServerRegex);
                if (fromServerMatch) {
                    fromServer = fromServerMatch[1].trim();
                }

                let byServer = '';
                const byServerMatch = rawValue.match(serverRegex);
                if (byServerMatch) {
                    byServer = byServerMatch[1].trim();
                }

                let ip = '';
                const ipMatch = rawValue.match(ipRegex);
                if (ipMatch) {
                    ip = validateIP(ipMatch[1] || ipMatch[2]);
                }

                let recipientEmail = '';
                const forMatch = rawValue.match(forRegex);
                if (forMatch) {
                    recipientEmail = parseEmailAddress(forMatch[1]);
                } else {
                    recipientEmail = globalRecipients[0] || '';
                }

                if (fromServer || byServer) {
                    transactions.push({
                        order: ++orderCounter,
                        action: 'Received',
                        timestamp: date,
                        fromServer: fromServer,
                        byServer: byServer,
                        ip: ip,
                        emailOrDomain: recipientEmail || globalSender || fromServer || byServer,
                        details: cleanedValue
                    });
                }
            } else {
                transactions.push({
                    order: ++orderCounter,
                    action: headerName,
                    timestamp: '',
                    fromServer: '',
                    byServer: '',
                    ip: '',
                    emailOrDomain: '',
                    details: headerValue
                });
            }
        });

        // Process Authentiction headers
        lastAuthResults = analyseAuthResults(headers);

        // Default sort
        sortState = { column: 'order', direction: 'asc' };
        sortTransactions(sortState.column, sortState.direction);

        // Process body
        const bodyParts = [];
        if (!body) {
            lastBodyContent = '<p>No body content provided.</p>';
            attachmentResultsDiv.innerHTML = '<p>No attachments found.</p>';
        } else {
            const contentTypeMatch = headers.match(contentTypeRegex) || [];
            let boundary = '';
            for (let match of contentTypeMatch) {
                const boundaryMatch = match.match(boundaryRegex);
                if (boundaryMatch) {
                    boundary = boundaryMatch[1];
                    break;
                }
            }

            if (boundary) {
                const parts = body.split(`--${boundary}`).filter(part => part.trim() && !part.startsWith('--'));
                lastBodyContent = parts.map((part, index) => {
                    const lines = part.trim().split('\n');
                    let contentType = '';
                    let encoding = '7bit';
                    let charset = 'utf-8';
                    let contentDisposition = '';
                    let content = '';
                    let inContent = false;
                    let filename = '';

                    for (let line of lines) {
                        if (!inContent && line.match(/^Content-Type:/i)) {
                            contentType = line.replace(/^Content-Type:\s*/i, '').trim();
                            const charsetMatch = contentType.match(/charset=["']?([^"'\s;]+)["']?/i);
                            if (charsetMatch) {
                                charset = charsetMatch[1].toLowerCase();
                            }
                        } else if (!inContent && line.match(/^Content-Transfer-Encoding:/i)) {
                            encoding = line.replace(/^Content-Transfer-Encoding:\s*/i, '').trim().toLowerCase();
                        } else if (!inContent && line.match(/^Content-Disposition:/i)) {
                            contentDisposition = line.replace(/^Content-Disposition:\s*/i, '').trim().toLowerCase();
                            const filenameMatch = line.match(filenameRegex);
                            if (filenameMatch) {
                                filename = filenameMatch[1];
                            }
                        } else if (!inContent && line.trim() === '') {
                            inContent = true;
                        } else if (inContent) {
                            content += line + '\n';
                        }
                    }

                    content = content.trim();
                    const isAttachment = contentDisposition.includes('attachment') ||
                        contentType.match(/^(application|image|audio|video)\//i) ||
                        (filename && !contentType.includes('text/'));

                    if (isAttachment && content && filename) {
                        let decodedContent = content;
                        let binaryContent;

                        if (encoding === 'base64') {
                            decodedContent = decodeBase64(content);
                            if (decodedContent === '') {
                                console.warn(`Failed to decode attachment: ${filename}`);
                                return '';
                            }
                            binaryContent = new Uint8Array(decodedContent.split('').map(char => char.charCodeAt(0)));
                        } else if (encoding === 'quoted-printable') {
                            decodedContent = decodeQuotedPrintable(content);
                            binaryContent = new Uint8Array(decodedContent.split('').map(char => char.charCodeAt(0)));
                        } else {
                            binaryContent = new Uint8Array(content.split('').map(char => char.charCodeAt(0)));
                        }

                        try {
                            const blob = new Blob([binaryContent], { type: contentType.split(';')[0] });
                            const dataUrl = URL.createObjectURL(blob);

                            attachments.push({
                                name: filename,
                                type: contentType.split(';')[0] || 'application/octet-stream',
                                dataUrl: dataUrl
                            });
                        } catch (e) {
                            console.warn(`Failed to create attachment for ${filename}:`, e);
                        }

                        return '';
                    }

                    if (encoding === 'base64') {
                        content = decodeBase64(content);
                        if (content === '') {
                            return `<p>Failed to decode base64 content for part ${index + 1}.</p>`;
                        }
                    } else if (encoding === 'quoted-printable') {
                        content = decodeQuotedPrintable(content);
                    }

                    bodyParts.push({ content, encoding });

                    if (contentType.includes('text/plain')) {
                        return `<h4>Plain Text</h4><pre>${escapeHtml(content)}</pre>`;
                    } else if (contentType.includes('text/html')) {
                        return `<h4>HTML Content</h4><div class="html-content">${sanitizeHtml(content)}</div>`;
                    }
                    return '';
                }).filter(part => part).join('');

                if (!lastBodyContent) {
                    lastBodyContent = '<p>No displayable body content provided.</p>';
                }
            } else {
                lastBodyContent = `<h4>Plain Text</h4><pre>${escapeHtml(body)}</pre>`;
                bodyParts.push({ content: body, encoding: '7bit' });
            }
        }

        renderTable(lastSpfResult, lastDkimResult, lastDmarcResult, lastBclResult, lastForefrontResult, lastAuthResults);
        toggleBodyContent();
        renderAttachments();

        const iocs = processIOCs(headers, bodyParts);
        renderIOCs(iocs);

    } catch (e) {
        console.error('Analysis failed:', e);
        emailDetailsDiv.innerHTML = '<p>Error analysing email: ' + escapeHtml(e.message) + '</p>';
        headerResultsDiv.innerHTML = '';
        bodyResultsDiv.innerHTML = '<p>Error processing body content.</p>';
        attachmentResultsDiv.innerHTML = '<p>No attachments found.</p>';
        iocResultsDiv.innerHTML = '<p>No IOCs found.</p>';
    }
}

function analyseAuthResults(headers) {
    if (typeof headers !== 'string') {
        return {
            status: 'N/A',
            fields: {
                SPFResult: '', DKIMResult: '', DMARCResult: '', Server: '', AuthDetails: ''
            },
            details: 'Headers must be a string'
        };
    }

    // Normalize headers to handle multi-line entries
    const normalizedHeaders = headers.replace(/\n\s+/g, ' ').trim();
    const authRegex = /^Authentication-Results:[^\n]*(?:\n\s+[^\n]*)*?(?=\n[A-Z-]|$)/gim;
    const authMatches = headers.match(authRegex) || [];

    if (authMatches.length === 0) {
        return {
            status: 'N/A',
            fields: {
                SPFResult: '', DKIMResult: '', DMARCResult: '', Server: '', AuthDetails: ''
            },
            details: 'Authentication-Results header is missing'
        };
    }

    // Use the last Authentication-Results header (closest to receiving server)
    const authHeader = authMatches[authMatches.length - 1].replace(/^Authentication-Results:\s*/, '').trim();
    const fields = {
        SPFResult: (authHeader.match(/spf=(\w+)/i) || [])[1] || '',
        DKIMResult: (authHeader.match(/dkim=(\w+)/i) || [])[1] || '',
        DMARCResult: (authHeader.match(/dmarc=(\w+)/i) || [])[1] || '',
        Server: (authHeader.match(/^([^;]+)/i) || [])[1]?.trim() || '',
        AuthDetails: (authHeader.match(/auth=([^;]+)/i) || [])[1] || ''
    };

    // Determine aggregate status
    let overallStatus = 'FAIL';
    if (fields.DMARCResult.toLowerCase() === 'pass') {
        overallStatus = 'PASS'; // DMARC pass takes precedence
    } else if (fields.SPFResult.toLowerCase() === 'pass' || fields.DKIMResult.toLowerCase() === 'pass') {
        overallStatus = 'PARTIAL'; // Either SPF or DKIM pass, but not DMARC
    } else if (fields.SPFResult || fields.DKIMResult || fields.DMARCResult) {
        overallStatus = 'FAIL'; // Some results present, but none pass
    } else {
        overallStatus = 'N/A'; // No results present
    }

    return {
        status: overallStatus,
        fields,
        details: authHeader
    };
}

function toggleAuthResultsDetails() {
    const authDetails = document.getElementById('auth-results-details');
    const toggleArrow = document.querySelector('.toggle-auth-results-arrow');
    if (authDetails && toggleArrow) {
        authDetails.classList.toggle('expanded');
        toggleArrow.textContent = authDetails.classList.contains('expanded') ? '▲' : '▼';
    }
}
 
    </script>
</body>
</html>
